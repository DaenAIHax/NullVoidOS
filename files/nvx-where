#!/usr/bin/env bash
set -euo pipefail

cmd="${1:-}"
[[ -n "$cmd" ]] || { echo "Usage: nvx-where <command>" >&2; exit 2; }

printf "TARGET\tFOUND\tPATH\n"
any=0

# HOST lookup
host_p=""
if command -v which >/dev/null 2>&1; then
  host_p="$(which "$cmd" 2>/dev/null || true)"
else
  host_p="$(command -v -- "$cmd" 2>/dev/null || true)"
fi

if [[ -n "$host_p" ]]; then
  printf "HOST\tyes\t%s\n" "$host_p"
  any=1
else
  printf "HOST\tno\t-\n"
fi

# "which" if available, else "command -v" \u2014 inside container
inner_lookup() {
  cat <<'SH'
if command -v which >/dev/null 2>&1; then
  which "$1" 2>/dev/null || true
else
  command -v -- "$1" 2>/dev/null || true
fi
SH
}

lookup_in_box() {
  local mode="$1" name="$2"
  local out p rc

  # IMPORTANT: do not let failures abort the whole script
  set +e
  if [[ "$mode" == "rootful" ]]; then
    out="$(distrobox-enter --root "$name" -- sh -lc "$(inner_lookup)" sh "$cmd" </dev/null 2>/dev/null)"
    rc=$?
  else
    out="$(distrobox-enter "$name" -- sh -lc "$(inner_lookup)" sh "$cmd" </dev/null 2>/dev/null)"
    rc=$?
  fi
  set -e

  # If enter failed, mark as no and continue
  if [[ "$rc" -ne 0 ]]; then
    printf "%s\tno\t-\n" "$name"
    return 0
  fi

  p="$(printf "%s" "$out" | head -n1 | tr -d '\r')"
  if [[ -n "$p" ]]; then
    printf "%s\tyes\t%s\n" "$name" "$p"
    any=1
  else
    printf "%s\tno\t-\n" "$name"
  fi
}

# ROOTFUL first
while IFS='|' read -r id name status image; do
  name="$(echo "${name:-}" | xargs)"
  [[ -n "$name" ]] || continue
  lookup_in_box rootful "$name"
done < <(distrobox list --root --no-color 2>/dev/null | tail -n +2)

# ROOTLESS second
while IFS='|' read -r id name status image; do
  name="$(echo "${name:-}" | xargs)"
  [[ -n "$name" ]] || continue
  lookup_in_box rootless "$name"
done < <(distrobox list --no-color 2>/dev/null | tail -n +2)

if [[ "$any" -ne 1 ]]; then
  echo "\u274c '$cmd' not found on host or in any distrobox container." >&2
  exit 127
fi

